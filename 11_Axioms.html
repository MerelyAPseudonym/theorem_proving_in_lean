<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2017-03-16 Thu 19:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Theorem Proving in Lean</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad, [[http://leodemoura.github.io][Leonardo de Moura]]Leonardo de Moura" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
</head>
<body>
<div id="content">
<h1 class="title">Theorem Proving in Lean</h1>

<div id="outline-container-org5ce9491" class="outline-2">
<h2 id="Axioms_and_Computation"><a id="org5ce9491"></a><span class="section-number-2"> 11</span> Axioms and Computation</h2>
<div class="outline-text-2" id="text-Axioms_and_Computation">
<p>
We have seen that the version of the Calculus of Inductive
Constructions that has been implemented in Lean includes dependent
function types, inductive types, and a hierarchy of universes that
starts with an impredicative, proof-irrelevant <code>Prop</code> at the
bottom. In this chapter, we consider ways of extending the CIC with
additional axioms and rules. Extending a foundational system in such a
way is often convenient; it can make it possible to prove more
theorems, as well as make it easier to prove theorems that could have
been proved otherwise. But there can be negative consequences of
adding additional axioms, consequences which may go beyond concerns
about their correctness. In particular, the use of axioms bears on the
computational content of definitions and theorems, in ways we will
explore here.
</p>

<p>
Lean is designed to support both computational and classical
reasoning. Users that are so inclined can stick to a "computationally
pure" fragment, which guarantees that closed expressions in the system
evaluate to canonical normal forms. In particular, any closed
computationally pure expression of type <code>ℕ</code>,  for example,
will reduce to a numeral.
</p>

<p>
Lean's standard library defines an additional axiom, propositional
extensionality, and a quotient construction which in turn implies the
principle of function extensionality. These extensions are used, for
example, to develop theories of sets and finite sets. We will see
below that using these theorems can block evaluation in Lean's kernel,
so that closed terms of type <code>ℕ</code> no longer evaluate to numerals. But
Lean erases types and propositional information when compiling
definitions to bytecode for its virtual machine evaluator, and since
these axioms only add new propositions, they are compatible with that
computational interpretation. Even computationally inclined users may
wish to use the classical law of the excluded middle to reason about
computation. This also blocks evaluation in the kernel, but it is
compatible with compilation to bytecode.
</p>

<p>
The standard library also defines a choice principle that is entirely
antithetical to a computational interpretation, since it magically
produces "data" from a proposition asserting its existence. Its use is
essential to some classical constructions, and users can import it
when needed. But expressions that use this construction to produce
data do not have computational content, and in Lean we are required to
mark such definitions as <code>noncomputable</code> to flag that fact.
</p>

<p>
Using a clever trick (known as Diaconescu's theorem), one can use
propositional extensionality, function extensionality, and choice to
derive the law of the excluded middle. As noted above, however, use
of the law of the excluded middle is still compatible with bytecode
compilation and code extraction, as are other classical principles, as
long as they are not used to manufacture data.
</p>

<p>
To summarize, then, on top of the underlying framework of universes,
dependent function types, and inductive types, the standard library
adds three additional components:
</p>
<ul class="org-ul">
<li>the axiom of propositional extensionality</li>
<li>a quotient construction, which implies function extensionality</li>
<li>a choice principle, which produces data from an existential
proposition.</li>
</ul>
<p>
The first two of these block normalization within Lean, but are
compatible with bytecode evaluation, whereas the third is not amenable
to computational interpretation. We will spell out the details more
precisely below.
</p>
</div>

<div id="outline-container-orge3e7655" class="outline-3">
<h3 id="orge3e7655"><span class="section-number-3"> 11.1</span> Historical and Philosophical Context</h3>
<div class="outline-text-3" id="text-1-1">
<p>
For most of its history, mathematics was essentially computational:
geometry dealt with constructions of geometric objects, algebra was
concerned with algorithmic solutions to systems of equations, and
analysis provided means to compute the future behavior of systems
evolving over time. From the proof of a theorem to the effect that
"for every <code>x</code>, there is a <code>y</code> such that &#x2026;", it was generally
straightforward to extract an algorithm to compute such a <code>y</code> given
<code>x</code>.
</p>

<p>
In the nineteenth century, however, increases in the complexity of
mathematical arguments pushed mathematicians to develop new styles of
reasoning that suppress algorithmic information and invoke
descriptions of mathematical objects that abstract away the details of
how those objects are represented. The goal was to obtain a powerful
"conceptual" understanding without getting bogged down in
computational details, but this had the effect of admitting
mathematical theorems that are simply <i>false</i> on a direct
computational reading.
</p>

<p>
There is still fairly uniform agreement today that computation is
important to mathematics. But there are different views as to how best
to address computational concerns. From a <i>constructive</i> point of
view, it is a mistake to separate mathematics from its computational
roots; every meaningful mathematical theorem should have a direct
computational interpretation. From a <i>classical</i> point of view, it is
more fruitful to maintain a separation of concerns: we can use one
language and body of methods to write computer programs, while
maintaining the freedom to use a nonconstructive theories and methods
to reason about them. Lean is designed to support both of these
approaches. Core parts of the library are developed constructively,
but the system also provides support for carrying out classical
mathematical reasoning.
</p>

<p>
Computationally, the purest part of dependent type theory avoids the
use of <code>Prop</code> entirely. Inductive types and dependent function types
can be viewed as data types, and terms of these types can be
"evaluated" by applying reduction rules until no more rules can be
applied. In principle, any closed term (that is, term with no free
variables) of type <code>ℕ</code> should evaluate to a numeral, <code>succ (... (succ
zero)...)</code>.
</p>

<p>
Introducing a proof-irrelevant <code>Prop</code> and marking theorems irreducible
represents a first step towards separation of concerns. The intention
is that elements of a type <code>p : Prop</code> should play no role in
computation, and so the particular construction of a term <code>t : p</code> is
"irrelevant" in that sense. One can still define computational objects
that incorporate elements of type <code>Prop</code>; the point is that these
elements can help us reason about the effects of the computation, but
can be ignored when we extract "code" from the term. Elements of type
<code>Prop</code> are not entirely innocuous, however. They include equations <code>s
= t : α</code> for any type <code>α</code>, and such equations can be used as casts, to
type check terms. Below, we will see examples of how such casts can
block computation in the system. However, computation is still
possible under an evaluation scheme that erases propositional content,
ignores intermediate typing constraints, and reduces terms until they
reach a normal form. This is precisely what Lean's virtual machine
does.
</p>

<p>
Having adopted a proof-irrelevant <code>Prop</code>, one might consider it
legitimate to use, for example, the law of the excluded middle, <code>p ∨
¬p</code>, where <code>p</code> is any proposition. Of course, this, too, can block
computation according to the rules of CIC, but it does not block
bytecode evaluation, as described above. It is only the choice
principles discussed in <a href="#" onclick="myModule.scrollTutorialTo('Choice_Axioms')">Section 11.5</a> that completely erasing the
distinction between the proof-irrelevant and data-relevant parts of
the theory.
</p>
</div>
</div>

<div id="outline-container-org448cae0" class="outline-3">
<h3 id="org448cae0"><span class="section-number-3"> 11.2</span> Propositional Extensionality</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Propositional extensionality is the following axiom:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-1' mode="ace/mode/lean" readonly="true">axiom propext {a b : Prop} : (a ↔ b) → a = b</juicy-ace-editor><div id='lean-full-code-1' style='display:none'>namespace hide

axiom propext {a b : Prop} : (a ↔ b) → a = b

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-1').text());">Try it yourself &raquo;</button></div>
</div>
<p>
It asserts that when two propositions imply one another, they are
actually equal. This is consistent with set-theoretic
interpretations in which any element <code>a : Prop</code> is either empty or the
singleton set <code>{*}</code>, for some distinguished element <code>*</code>. The axiom has
the effect that equivalent propositions can be substituted for one
another in any context:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-2' mode="ace/mode/lean" readonly="true">section
  variables a b c d e : Prop
  variable p : Prop → Prop

  example (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
  propext h ▸ iff.refl _

  example (h : a ↔ b) (h₁ : p a) : p b :=
  propext h ▸ h₁
end
</juicy-ace-editor><div id='lean-full-code-2' style='display:none'>section
  variables a b c d e : Prop
  variable p : Prop → Prop

  example (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
  propext h ▸ iff.refl _

  example (h : a ↔ b) (h₁ : p a) : p b :=
  propext h ▸ h₁
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-2').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The first example could be proved more laboriously without <code>propext</code>
using the fact that the propositional connectives respect
propositional equivalence. The second example represents a more
essential use of <code>propext</code>. In fact, it is equivalent to <code>propext</code>
itself, a fact which we encourage you to prove.
</p>

<p>
Given any definition or theorem in Lean, you can use the <code>print
axioms</code> command to display the axioms it depends on.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">print axioms thm₁  -- propext
print axioms thm₂  -- propext</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>variables a b c d e : Prop
variable p : Prop → Prop

theorem thm₁ (h : a ↔ b) : (c ∧ a ∧ d → e) ↔ (c ∧ b ∧ d → e) :=
propext h ▸ iff.refl _

theorem thm₂ (h : a ↔ b) (h₁ : p a) : p b :=
propext h ▸ h₁

print axioms thm₁  -- propext
print axioms thm₂  -- propext
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-orgdcabd8e" class="outline-3">
<h3 id="orgdcabd8e"><span class="section-number-3"> 11.3</span> Function Extensionality</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Similar to propositional extensionality, function extensionality
asserts that any two functions of type <code>Π x : α, β x</code> that agree on
all their inputs are equal.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-4' mode="ace/mode/lean" readonly="true">universes u₁ u₂

check (@funext : ∀ {α : Type u₁} {β : α → Type u₂} {f₁ f₂ : Π (x : α), β x},
        (∀ (x : α), f₁ x = f₂ x) → f₁ = f₂)
</juicy-ace-editor><div id='lean-full-code-4' style='display:none'>universes u₁ u₂

check (@funext : ∀ {α : Type u₁} {β : α → Type u₂} {f₁ f₂ : Π (x : α), β x},
        (∀ (x : α), f₁ x = f₂ x) → f₁ = f₂)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-4').text());">Try it yourself &raquo;</button></div>
</div>
<p>
From a classical, set-theoretic perspective, this is exactly what it
means for two functions to be equal. This is known as an "extensional"
view of functions. From a constructive perspective, however, it is
sometimes more natural to think of functions as algorithms, or
computer programs, that are presented in some explicit way. It is
certainly the case that two computer programs can compute the same
answer for every input despite the fact that they are syntactically
quite different. In much the same way, you might want to maintain a
view of functions that does not force you to identify two functions
that have the same input / output behavior. This is known as an
"intensional" view of functions.
</p>

<p>
In fact, function extensionality follows from the existence of
quotients, which we describe in the next section. In the Lean standard
library, therefore, <code>funext</code> is thus <a target='_blank' href="https://github.com/leanprover/lean/blob/master/library/init/funext.lean">proved from the quotient
construction</a>.
</p>

<p>
Suppose that for <code>α : Type</code> we define the <code>set α := α → Prop</code> to
denote the type of subsets of <code>α</code>, essentially identifying subsets
with predicates. By combining <code>funext</code> and <code>propext</code>, we obtain an
extensional theory of such sets:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">universe u

def set (α : Type u) := α → Prop

namespace set

variable {α : Type u}

definition mem (x : α) (a : set α) := a x
notation e ∈ a := mem e a 

theorem setext {a b : set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
funext (take x, propext (h x))

end set</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>namespace hide

universe u

def set (α : Type u) := α → Prop

namespace set

variable {α : Type u}

definition mem (x : α) (a : set α) := a x
notation e ∈ a := mem e a 

theorem setext {a b : set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
funext (take x, propext (h x))

end set
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can then proceed to define the empty set and set intersection, for
example, and prove set identities:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">definition empty : set α := λ x, false
local notation `∅` := empty

definition inter (a b : set α) : set α := λ x, x ∈ a ∧ x ∈ b
notation a ∩ b := inter a b

theorem inter_self (a : set α) : a ∩ a = a :=
setext (take x, and_self _)

theorem inter_empty (a : set α) : a ∩ ∅ = ∅ :=
setext (take x, and_false _)

theorem empty_inter (a : set α) : ∅ ∩ a = ∅ :=
setext (take x, false_and _)

theorem inter.comm (a b : set α) : a ∩ b = b ∩ a :=
setext (take x, and_comm _ _)</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>namespace hide

universe u

definition set (α : Type u) := α → Prop

namespace set

variable {α : Type u}

def mem (x : α) (a : set α) := a x

instance has_mem_set (α : Type u) : has_mem α (set α) := ⟨mem⟩

theorem setext {a b : set α} (h : ∀ x, x ∈ a ↔ x ∈ b) : a = b :=
funext (take x, propext (h x))

definition empty : set α := λ x, false
local notation `∅` := empty

definition inter (a b : set α) : set α := λ x, x ∈ a ∧ x ∈ b
notation a ∩ b := inter a b

theorem inter_self (a : set α) : a ∩ a = a :=
setext (take x, and_self _)

theorem inter_empty (a : set α) : a ∩ ∅ = ∅ :=
setext (take x, and_false _)

theorem empty_inter (a : set α) : ∅ ∩ a = ∅ :=
setext (take x, false_and _)

theorem inter.comm (a b : set α) : a ∩ b = b ∩ a :=
setext (take x, and_comm _ _)

end set
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>

<p>
The following is an example of how function extensionality blocks
computation inside the Lean kernel.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">def f₁  (x : ℕ) := x
def f₂ (x : ℕ) := 0 + x

theorem feq : f₁ = f₂ := funext (take x, (zero_add x)^.symm)

def val : ℕ := eq.rec_on feq (0 : ℕ)

-- complicated!
eval val

-- evaluates to 0
vm_eval val
</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>def f₁  (x : ℕ) := x
def f₂ (x : ℕ) := 0 + x

theorem feq : f₁ = f₂ := funext (take x, (zero_add x)^.symm)

def val : ℕ := eq.rec_on feq (0 : ℕ)

-- complicated!
eval val

-- evaluates to 0
vm_eval val
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>
<p>
First, we show that the two functions <code>f₁</code> and <code>f₂</code> are equal using
function extensionality, and then we cast <code>0</code> of type <code>ℕ</code> by
replacing <code>f₁</code> by <code>f₂</code> in the type. Of course, the cast is vacuous,
because <code>ℕ</code> does not depend on <code>f₁</code>. But that is enough to do the
damage: under the computational rules of the system, we now have a
closed term of <code>ℕ</code> that does not reduce to a numeral. In this case, we
may be tempted to reduce the expression to <code>0</code>. But in nontrivial
examples, eliminating cast changes the type of the term, which might
make an ambient expression type incorrect. The virtual machine,
however, has no trouble evaluating the expression to <code>0</code>. Here is a
similarly contrived example that shows how <code>propext</code> can get in the
way.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">theorem tteq : (true ∧ true) = true := propext (and_true true)

def val : ℕ := eq.rec_on tteq 0

-- complicated!
eval val

-- evaluates to 0
vm_eval val
</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>theorem tteq : (true ∧ true) = true := propext (and_true true)

def val : ℕ := eq.rec_on tteq 0

-- complicated!
eval val

-- evaluates to 0
vm_eval val
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Current research programs, including work on
<i>observational type theory</i> and <i>cubical type theory</i>, aim to extend
type theory in ways that permit reductions for casts involving
function extensionality, quotients, and more. But the solutions are
not so clear cut, and the rules of Lean's underlying calculus do not
sanction such reductions.
</p>

<p>
In a sense, however, a cast does not change the meaning of an
expression. Rather, it is a mechanism to reason about the expression's
type. Given an appropriate semantics, it then makes sense to reduce
terms in ways that preserve their meaning, ignoring the intermediate
bookkeeping needed to make the reductions type correct. In that case,
adding new axioms in <code>Prop</code> does not matter; by proof irrelevance, an
expression in <code>Prop</code> carries no information, and can be safely ignored
by the reduction procedures.
</p>
</div>
</div>

<div id="outline-container-org34747de" class="outline-3">
<h3 id="org34747de"><span class="section-number-3"> 11.4</span> Quotients</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Let <code>α</code> be any type, and let <code>r</code> be an equivalence relation on <code>α</code>. It
is mathematically common to form the "quotient" <code>α / r</code>, that is, the
type of elements of <code>α</code> "modulo" <code>r</code>. Set theoretically, one can view
<code>α / r</code> as the set of equivalence classes of <code>α</code> modulo <code>r</code>. If <code>f : α 
→ β</code> is any function that respects the equivalence relation in the
sense that for every <code>x y : α</code>, <code>r x y</code> implies <code>f x = f y</code>, then <code>f</code>
"lifts" to a function <code>f' : α / r → β</code> defined on each equivalence
class <code>⟦x⟧</code> by <code>f' ⟦x⟧ = f x</code>. Lean's standard library extends the
Calculus of Inductive Constructions with additional constants that
perform exactly these constructions, and installs this last equation
as a definitional reduction rule.
</p>

<p>
In its most basic form, the quotient construction does not even
require <code>r</code> to be an equivalence relation. The following constants
are built into Lean:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">universes u v

constant quot       : Π {α : Sort u}, (α → α → Prop) → Sort u
constant quot.mk    : Π {α : Sort u} (r : α → α → Prop), α → quot r

axiom    quot.ind   : ∀ {α : Sort u} {r : α → α → Prop} {β : quot r → Prop},
                       (∀ a, β (quot.mk r a)) → ∀ (q : quot r), β q

constant quot.lift  : Π {α : Sort u} {r : α → α → Prop} {β : Sort u} (f : α → β),
                       (∀ a b, r a b → f a = f b) → quot r → β
</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>namespace hide
universes u v

constant quot       : Π {α : Sort u}, (α → α → Prop) → Sort u
constant quot.mk    : Π {α : Sort u} (r : α → α → Prop), α → quot r

axiom    quot.ind   : ∀ {α : Sort u} {r : α → α → Prop} {β : quot r → Prop},
                       (∀ a, β (quot.mk r a)) → ∀ (q : quot r), β q

constant quot.lift  : Π {α : Sort u} {r : α → α → Prop} {β : Sort u} (f : α → β),
                       (∀ a b, r a b → f a = f b) → quot r → β

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The first one forms a type <code>quot r</code> given a type <code>α</code> by any binary
relation <code>r</code> on <code>α</code>. The second maps <code>α</code> to <code>quot α</code>, so that for any
<code>a : α</code>, <code>quot.mk a</code> is an element of <code>quot r</code>. The third principle,
<code>quot.ind</code>, says that every element of <code>quot.mk a</code> is of this
form. Given any function <code>f</code> and a proof <code>h</code> that respects the relation <code>r</code>,
<code>quot.lift f h</code> is the corresponding function on <code>quot r</code>. The idea is
that for any element <code>a</code> in <code>α</code>, <code>quot.lift f h</code> is the function which
maps <code>quot.mk r a</code> to <code>f a</code>, wherein <code>h</code> shows that this fuction is
well defined. In fact, the computation principle is declared as a
reduction rule, as the proof below makes clear.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">variables α β : Type
variable  r : α → α → Prop
variable  a : α

-- the quotient type
check (quot r : Type)

-- the class of a
check (quot.mk r a : quot r)

variable  f : α → β
premise   h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂ 

-- the corresponding function on quot r
check (quot.lift f h : quot r → β)

-- the computation principle
theorem thm : quot.lift f h (quot.mk r a) = f a := rfl
</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>variables α β : Type
variable  r : α → α → Prop
variable  a : α

-- the quotient type
check (quot r : Type)

-- the class of a
check (quot.mk r a : quot r)

variable  f : α → β
premise   h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂ 

-- the corresponding function on quot r
check (quot.lift f h : quot r → β)

-- the computation principle
theorem thm : quot.lift f h (quot.mk r a) = f a := rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>

<p>
The four constants, <code>quot</code>, <code>quot.mk</code>, <code>quot.ind</code>, and <code>quot.lift</code> in
and of themselves are not very strong. You can check that the
<code>quot.ind</code> is satisfied if we take <code>quot r</code> to be simply <code>α</code>, and take
<code>quot.lift</code> to be the identity function (ignoring <code>h</code>). For that
reason, these four constants are not viewed as additional axioms:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">print axioms thm   -- no axioms</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>variables α β : Type
variable  r : α → α → Prop
variable  a : α
variable  f : α → β
premise   h : ∀ a₁ a₂, r a₁ a₂ → f a₁ = f a₂ 
theorem thm : quot.lift f h (quot.mk r a) = f a := rfl

print axioms thm   -- no axioms
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>
<p>
They are, like inductively defined types and the associated
constructors and recursors, viewed as part of the logical framework.
</p>

<p>
What makes the <code>quot</code> construction into a bona fide quotient is the
following additional axiom:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">axiom quot.sound : ∀ {α : Type u} {r : α → α → Prop} {a b : α},
                     r a b → quot.mk r a = quot.mk r b</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>namespace hide
universe u

axiom quot.sound : ∀ {α : Type u} {r : α → α → Prop} {a b : α},
                     r a b → quot.mk r a = quot.mk r b
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
<p>
This is the axiom that asserts that any two element of <code>α</code> that are
related by <code>r</code> become identified in the quotient. If a theorem or
definition makes use of <code>quot.sound</code>, it will show up in the <code>print
axioms</code> command.
</p>

<p>
Of course, the quotient construction is most commonly used in
situations when <code>r</code> is an equivalence relation. Given <code>r</code> as above, it
is not hard to see that the relation <code>r' a b</code> defined by <code>quot.mk r a
= quot.mk r b</code> is an equivalence relation. The axiom <code>quot.sound</code> says
that <code>r a b</code> implies <code>r' a b</code>. Using <code>quot.lift</code> and <code>quot.ind</code>, we
can show that the latter is the smallest equivalence relation
containing <code>r</code>, in the sense that if <code>r'' a b</code> is any equivalence
relation containing <code>r</code>, the <code>r' a b</code> implies <code>r'' a b</code>. In
particular, if <code>r</code> was an equivalence relation to start with, 
then <code>r a b</code> holds iff <code>r' a b</code> for every <code>a</code> and <code>b</code>.
</p>

<p>
To support this common use case, the standard library defines the
notion of a <i>setoid</i>, which is simply a type with an associated
equivalence relation:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">class setoid (α : Type u) :=
(r : α → α → Prop) (iseqv : equivalence r)

namespace setoid
  infix `≈` := setoid.r

  variable {α : Type u}
  variable [s : setoid α]
  include s

  theorem refl (a : α) : a ≈ a :=
  (@setoid.iseqv α s)^.left a

  theorem symm {a b : α} : a ≈ b → b ≈ a :=
  λ h, (@setoid.iseqv α s)^.right^.left h

  theorem trans {a b c : α} : a ≈ b → b ≈ c → a ≈ c :=
  λ h₁ h₂, (@setoid.iseqv α s)^.right^.right h₁ h₂
end setoid</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>universe u
namespace hide

class setoid (α : Type u) :=
(r : α → α → Prop) (iseqv : equivalence r)

namespace setoid
  infix `≈` := setoid.r

  variable {α : Type u}
  variable [s : setoid α]
  include s

  theorem refl (a : α) : a ≈ a :=
  (@setoid.iseqv α s)^.left a

  theorem symm {a b : α} : a ≈ b → b ≈ a :=
  λ h, (@setoid.iseqv α s)^.right^.left h

  theorem trans {a b c : α} : a ≈ b → b ≈ c → a ≈ c :=
  λ h₁ h₂, (@setoid.iseqv α s)^.right^.right h₁ h₂
end setoid

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Given a type <code>α</code>, a relation <code>r</code> on <code>α</code>, and a proof <code>p</code> that <code>r</code> is
an equivalence relation, we can define <code>setoid.mk p</code> as an instance of
the setoid class. 
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">def quotient {α : Type u} (s : setoid α) :=
@quot α setoid.r</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>universe u
namespace hide

def quotient {α : Type u} (s : setoid α) :=
@quot α setoid.r

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The constants <code>quotient.mk</code>, <code>quotient.ind</code>, <code>quotient.lift</code>, and
<code>quotient.sound</code> are nothing more than the specializations of the
corresponding elements of <code>quot</code>. The fact that type class inference
can find the setoid associated to a type <code>α</code> brings a number of
benefits. First, we can use the notation <code>a ≈ b</code> (entered with <code>\eq</code>
in Emacs) for <code>setoid.r a b</code>, where the instance of <code>setoid</code> is
implicit in the notation <code>setoid.r</code>. We can use the generic theorems
<code>setoid.refl</code>, <code>setoid.symm</code>, <code>setoid.trans</code> to reason about the
relation. Specifically with quotients we can use the generic notation
<code>⟦a⟧</code> for <code>quot.mk setoid.r</code> where the instance of <code>setoid</code> is
implicit in the notation <code>setoid.r</code>, as well as the theorem
<code>quotient.exact</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">check (@quotient.exact : ∀ {α : Type u} [setoid α] {a b : α}, ⟦a⟧ = ⟦b⟧ → a ≈ b)</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>universe u

check (@quotient.exact : ∀ {α : Type u} [setoid α] {a b : α}, ⟦a⟧ = ⟦b⟧ → a ≈ b)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Together with <code>quotient.sound</code>, this implies that the elements of the
quotient correspond exactly to the equivalence classes of elements in
<code>α</code>.
</p>

<p>
Recall that in the standard library, <code>α × β</code> represents the Cartesian
product of the types <code>α</code> and <code>β</code>.  To illustrate the use of quotients,
let us define the type of <i>unordered</i> pairs of elements of a type <code>α</code>
as a quotient of the type <code>α × α</code>. First, we define the
relevant equivalence relation:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-16' mode="ace/mode/lean" readonly="true">universe u

private definition eqv {α : Type u} (p₁ p₂ : α × α) : Prop :=
(p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

infix `~` := eqv
</juicy-ace-editor><div id='lean-full-code-16' style='display:none'>universe u

private definition eqv {α : Type u} (p₁ p₂ : α × α) : Prop :=
(p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

infix `~` := eqv
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-16').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The next step is to prove that <code>eqv</code> is in fact an equivalence
relation, which is to say, it is reflexive, symmetric and
transitive. We can prove these three facts in a convenient and
readable way by using dependent pattern matching to perform
case-analysis and break the hypotheses into pieces that are then
reassembled to produce the conclusion.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-17' mode="ace/mode/lean" readonly="true">open or eq

private theorem eqv.refl {α : Type u} : ∀ p : α × α, p ~ p :=
take p, inl ⟨rfl, rfl⟩

private theorem eqv.symm {α : Type u} : ∀ p₁ p₂ : α × α, p₁ ~ p₂ → p₂ ~ p₁
| (a₁, a₂) (b₁, b₂) (inl ⟨a₁b₁, a₂b₂⟩) := inl ⟨symm a₁b₁, symm a₂b₂⟩
| (a₁, a₂) (b₁, b₂) (inr ⟨a₁b₂, a₂b₁⟩) := inr ⟨symm a₂b₁, symm a₁b₂⟩

private theorem eqv.trans {α : Type u} : ∀ p₁ p₂ p₃ : α × α, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inl ⟨trans a₁b₁ b₁c₁, trans a₂b₂ b₂c₂⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inr ⟨trans a₁b₁ b₁c₂, trans a₂b₂ b₂c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inr ⟨trans a₁b₂ b₂c₂, trans a₂b₁ b₁c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inl ⟨trans a₁b₂ b₂c₁, trans a₂b₁ b₁c₂⟩

private theorem is_equivalence (α : Type u) : equivalence (@eqv α) :=
mk_equivalence (@eqv α) (@eqv.refl α) (@eqv.symm α) (@eqv.trans α)</juicy-ace-editor><div id='lean-full-code-17' style='display:none'>universe u

private definition eqv {α : Type u} (p₁ p₂ : α × α) : Prop :=
(p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

local infix `~` := eqv

open or eq

private theorem eqv.refl {α : Type u} : ∀ p : α × α, p ~ p :=
take p, inl ⟨rfl, rfl⟩

private theorem eqv.symm {α : Type u} : ∀ p₁ p₂ : α × α, p₁ ~ p₂ → p₂ ~ p₁
| (a₁, a₂) (b₁, b₂) (inl ⟨a₁b₁, a₂b₂⟩) := inl ⟨symm a₁b₁, symm a₂b₂⟩
| (a₁, a₂) (b₁, b₂) (inr ⟨a₁b₂, a₂b₁⟩) := inr ⟨symm a₂b₁, symm a₁b₂⟩

private theorem eqv.trans {α : Type u} : ∀ p₁ p₂ p₃ : α × α, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inl ⟨trans a₁b₁ b₁c₁, trans a₂b₂ b₂c₂⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inr ⟨trans a₁b₁ b₁c₂, trans a₂b₂ b₂c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inr ⟨trans a₁b₂ b₂c₂, trans a₂b₁ b₁c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inl ⟨trans a₁b₂ b₂c₁, trans a₂b₁ b₁c₂⟩

private theorem is_equivalence (α : Type u) : equivalence (@eqv α) :=
mk_equivalence (@eqv α) (@eqv.refl α) (@eqv.symm α) (@eqv.trans α)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-17').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We open the namespaces <code>or</code> and <code>eq</code> to be able to use <code>or.inl</code>,
<code>or.inr</code>, and <code>eq.trans</code> more conveniently.
</p>

<p>
Now that we have proved that <code>eqv</code> is an equivalence relation, we can
construct a <code>setoid (α × α)</code>, and use it to define the type <code>uprod α</code>
of unordered pairs. 
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-18' mode="ace/mode/lean" readonly="true">instance uprod.setoid (α : Type u) : setoid (α × α) :=
setoid.mk (@eqv α) (is_equivalence α)

definition uprod (α : Type u) : Type u :=
quotient (uprod.setoid α)

namespace uprod
  definition mk {α : Type u} (a₁ a₂ : α) : uprod α :=
  ⟦(a₁, a₂)⟧

  local notation `{` a₁ `,` a₂ `}` := mk a₁ a₂ 
end uprod</juicy-ace-editor><div id='lean-full-code-18' style='display:none'>universe u

private definition eqv {α : Type u} (p₁ p₂ : α × α) : Prop :=
(p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

local infix `~` := eqv

open or eq

private theorem eqv.refl {α : Type u} : ∀ p : α × α, p ~ p :=
take p, inl ⟨rfl, rfl⟩

private theorem eqv.symm {α : Type u} : ∀ p₁ p₂ : α × α, p₁ ~ p₂ → p₂ ~ p₁
| (a₁, a₂) (b₁, b₂) (inl ⟨a₁b₁, a₂b₂⟩) := inl ⟨symm a₁b₁, symm a₂b₂⟩
| (a₁, a₂) (b₁, b₂) (inr ⟨a₁b₂, a₂b₁⟩) := inr ⟨symm a₂b₁, symm a₁b₂⟩

private theorem eqv.trans {α : Type u} : ∀ p₁ p₂ p₃ : α × α, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inl ⟨trans a₁b₁ b₁c₁, trans a₂b₂ b₂c₂⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inr ⟨trans a₁b₁ b₁c₂, trans a₂b₂ b₂c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inr ⟨trans a₁b₂ b₂c₂, trans a₂b₁ b₁c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inl ⟨trans a₁b₂ b₂c₁, trans a₂b₁ b₁c₂⟩

private theorem is_equivalence (α : Type u) : equivalence (@eqv α) :=
mk_equivalence (@eqv α) (@eqv.refl α) (@eqv.symm α) (@eqv.trans α)

instance uprod.setoid (α : Type u) : setoid (α × α) :=
setoid.mk (@eqv α) (is_equivalence α)

definition uprod (α : Type u) : Type u :=
quotient (uprod.setoid α)

namespace uprod
  definition mk {α : Type u} (a₁ a₂ : α) : uprod α :=
  ⟦(a₁, a₂)⟧

  local notation `{` a₁ `,` a₂ `}` := mk a₁ a₂ 
end uprod
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-18').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that we locally define the notation <code>{a₁, a₂}</code> for ordered
pairs as <code>⟦(a₁, a₂)⟧</code>. This is useful for illustrative purposes, but
it is not a good idea in general, since the notation will shadow other
uses of curly brackets, such as for records and sets.
</p>

<p>
We can easily prove that <code>{a₁, a₂} = {a₂, a₁}</code> using <code>quot.sound</code>,
since we have <code>(a₁, a₂) ~ (a₂, a₁)</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-19' mode="ace/mode/lean" readonly="true">  theorem mk_eq_mk {α : Type} (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
  quot.sound (inr ⟨rfl, rfl⟩)</juicy-ace-editor><div id='lean-full-code-19' style='display:none'>universe u

private definition eqv {α : Type u} (p₁ p₂ : α × α) : Prop :=
(p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

local infix `~` := eqv

open or eq

private theorem eqv.refl {α : Type u} : ∀ p : α × α, p ~ p :=
take p, inl ⟨rfl, rfl⟩

private theorem eqv.symm {α : Type u} : ∀ p₁ p₂ : α × α, p₁ ~ p₂ → p₂ ~ p₁
| (a₁, a₂) (b₁, b₂) (inl ⟨a₁b₁, a₂b₂⟩) := inl ⟨symm a₁b₁, symm a₂b₂⟩
| (a₁, a₂) (b₁, b₂) (inr ⟨a₁b₂, a₂b₁⟩) := inr ⟨symm a₂b₁, symm a₁b₂⟩

private theorem eqv.trans {α : Type u} : ∀ p₁ p₂ p₃ : α × α, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inl ⟨trans a₁b₁ b₁c₁, trans a₂b₂ b₂c₂⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inr ⟨trans a₁b₁ b₁c₂, trans a₂b₂ b₂c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inr ⟨trans a₁b₂ b₂c₂, trans a₂b₁ b₁c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inl ⟨trans a₁b₂ b₂c₁, trans a₂b₁ b₁c₂⟩

private theorem is_equivalence (α : Type u) : equivalence (@eqv α) :=
mk_equivalence (@eqv α) (@eqv.refl α) (@eqv.symm α) (@eqv.trans α)

instance uprod.setoid (α : Type u) : setoid (α × α) :=
setoid.mk (@eqv α) (is_equivalence α)

definition uprod (α : Type u) : Type u :=
quotient (uprod.setoid α)

namespace uprod
  definition mk {α : Type u} (a₁ a₂ : α) : uprod α :=
  ⟦(a₁, a₂)⟧

  local notation `{` a₁ `,` a₂ `}` := mk a₁ a₂  

  theorem mk_eq_mk {α : Type} (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
  quot.sound (inr ⟨rfl, rfl⟩)
end uprod
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-19').text());">Try it yourself &raquo;</button></div>
</div>

<p>
To complete the example, given <code>a : α</code> and <code>u : uprod α</code>, we define
the proposition <code>a ∈ u</code> which should hold if <code>a</code> is one of the
elements of the unordered pair <code>u</code>.  First, we define a similar
proposition <code>mem_fn a u</code> on (ordered) pairs; then we show that
<code>mem_fn</code> respects the equivalence relation <code>eqv</code> with the lemma
<code>mem_respects</code>. This is an idiom that is used extensively in the Lean
standard library.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-20' mode="ace/mode/lean" readonly="true">  private definition mem_fn {α : Type} (a : α) : α × α → Prop
  | (a₁, a₂) := a = a₁ ∨ a = a₂

  -- auxiliary lemma for proving mem_respects
  private lemma mem_swap {α : Type} {a : α} : ∀ {p : α × α}, mem_fn a p = mem_fn a (⟨p.2, p.1⟩)
  | (a₁, a₂) := propext (iff.intro
      (λ l : a = a₁ ∨ a = a₂, or.elim l (λ h₁, inr h₁) (λ h₂, inl h₂))
      (λ r : a = a₂ ∨ a = a₁, or.elim r (λ h₁, inr h₁) (λ h₂, inl h₂)))

  private lemma mem_respects {α : Type} : ∀ {p₁ p₂ : α × α} (a : α),  p₁ ~ p₂ → mem_fn a p₁ = mem_fn a p₂
  | (a₁, a₂) (b₁, b₂) a (inl ⟨a₁b₁, a₂b₂⟩) :=
    begin dsimp at a₁b₁, dsimp at a₂b₂, rewrite [a₁b₁, a₂b₂] end
  | (a₁, a₂) (b₁, b₂) a (inr ⟨a₁b₂, a₂b₁⟩) :=
    begin dsimp at a₁b₂, dsimp at a₂b₁, rewrite [a₁b₂, a₂b₁], apply mem_swap end

  def mem {α : Type} (a : α) (u : uprod α) : Prop :=
  quot.lift_on u (λ p, mem_fn a p) (λ p₁ p₂ e, mem_respects a e)

  local infix `∈` := mem

  theorem mem_mk_left {α : Type} (a b : α) : a ∈ {a, b} :=
  inl rfl

  theorem mem_mk_right {α : Type} (a b : α) : b ∈ {a, b} :=
  inr rfl

  theorem mem_or_mem_of_mem_mk {α : Type} {a b c : α} : c ∈ {a, b} → c = a ∨ c = b :=
  λ h, h</juicy-ace-editor><div id='lean-full-code-20' style='display:none'>universe u

private definition eqv {α : Type u} (p₁ p₂ : α × α) : Prop :=
(p₁.1 = p₂.1 ∧ p₁.2 = p₂.2) ∨ (p₁.1 = p₂.2 ∧ p₁.2 = p₂.1)

local infix `~` := eqv

open or eq

private theorem eqv.refl {α : Type u} : ∀ p : α × α, p ~ p :=
take p, inl ⟨rfl, rfl⟩

private theorem eqv.symm {α : Type u} : ∀ p₁ p₂ : α × α, p₁ ~ p₂ → p₂ ~ p₁
| (a₁, a₂) (b₁, b₂) (inl ⟨a₁b₁, a₂b₂⟩) := inl ⟨symm a₁b₁, symm a₂b₂⟩
| (a₁, a₂) (b₁, b₂) (inr ⟨a₁b₂, a₂b₁⟩) := inr ⟨symm a₂b₁, symm a₁b₂⟩

private theorem eqv.trans {α : Type u} : ∀ p₁ p₂ p₃ : α × α, p₁ ~ p₂ → p₂ ~ p₃ → p₁ ~ p₃
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inl ⟨trans a₁b₁ b₁c₁, trans a₂b₂ b₂c₂⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inl ⟨a₁b₁, a₂b₂⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inr ⟨trans a₁b₁ b₁c₂, trans a₂b₂ b₂c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inl ⟨b₁c₁, b₂c₂⟩) :=
  inr ⟨trans a₁b₂ b₂c₂, trans a₂b₁ b₁c₁⟩
| (a₁, a₂) (b₁, b₂) (c₁, c₂) (inr ⟨a₁b₂, a₂b₁⟩) (inr ⟨b₁c₂, b₂c₁⟩) :=
  inl ⟨trans a₁b₂ b₂c₁, trans a₂b₁ b₁c₂⟩

private theorem is_equivalence (α : Type u) : equivalence (@eqv α) :=
mk_equivalence (@eqv α) (@eqv.refl α) (@eqv.symm α) (@eqv.trans α)

instance uprod.setoid (α : Type u) : setoid (α × α) :=
setoid.mk (@eqv α) (is_equivalence α)

definition uprod (α : Type u) : Type u :=
quotient (uprod.setoid α)

namespace uprod
  definition mk {α : Type u} (a₁ a₂ : α) : uprod α :=
  ⟦(a₁, a₂)⟧

  local notation `{` a₁ `,` a₂ `}` := mk a₁ a₂  

  theorem mk_eq_mk {α : Type} (a₁ a₂ : α) : {a₁, a₂} = {a₂, a₁} :=
  quot.sound (inr ⟨rfl, rfl⟩)

  private definition mem_fn {α : Type} (a : α) : α × α → Prop
  | (a₁, a₂) := a = a₁ ∨ a = a₂

  -- auxiliary lemma for proving mem_respects
  private lemma mem_swap {α : Type} {a : α} : ∀ {p : α × α}, mem_fn a p = mem_fn a (⟨p.2, p.1⟩)
  | (a₁, a₂) := propext (iff.intro
      (λ l : a = a₁ ∨ a = a₂, or.elim l (λ h₁, inr h₁) (λ h₂, inl h₂))
      (λ r : a = a₂ ∨ a = a₁, or.elim r (λ h₁, inr h₁) (λ h₂, inl h₂)))

  private lemma mem_respects {α : Type} : ∀ {p₁ p₂ : α × α} (a : α),  p₁ ~ p₂ → mem_fn a p₁ = mem_fn a p₂
  | (a₁, a₂) (b₁, b₂) a (inl ⟨a₁b₁, a₂b₂⟩) :=
    begin dsimp at a₁b₁, dsimp at a₂b₂, rewrite [a₁b₁, a₂b₂] end
  | (a₁, a₂) (b₁, b₂) a (inr ⟨a₁b₂, a₂b₁⟩) :=
    begin dsimp at a₁b₂, dsimp at a₂b₁, rewrite [a₁b₂, a₂b₁], apply mem_swap end

  def mem {α : Type} (a : α) (u : uprod α) : Prop :=
  quot.lift_on u (λ p, mem_fn a p) (λ p₁ p₂ e, mem_respects a e)

  local infix `∈` := mem

  theorem mem_mk_left {α : Type} (a b : α) : a ∈ {a, b} :=
  inl rfl

  theorem mem_mk_right {α : Type} (a b : α) : b ∈ {a, b} :=
  inr rfl

  theorem mem_or_mem_of_mem_mk {α : Type} {a b c : α} : c ∈ {a, b} → c = a ∨ c = b :=
  λ h, h
end uprod
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-20').text());">Try it yourself &raquo;</button></div>
</div>

<p>
For convenience, the standard library also defines <code>quotient.lift₂</code>
for lifting binary functions, and <code>quotient.ind₂</code> for induction on two
variables.
</p>

<p>
We close this section with some hints as to why the quotient construction
implies function extenionality. It is not hard to show that
extensional equality on the <code>Π x : α, β x</code> is an equivalence relation,
and so we can consider the type <code>extfun α β</code> of functions "up to
equivalence." Of course, application  respects that equivalence
in the sense that if <code>f₁</code> is equivalent to <code>f₂</code>, then <code>f₁ a</code> is equal
to <code>f₂ a</code>. Thus application gives rise to a function 
<code>extfun_app : extfun α β → Π x : α, β x</code>. But for every <code>f</code>,
<code>extfun_app ⟦f⟧</code> is definitionally equal to <code>λ x, f x</code>, which is in turn
definitionally equal to <code>f</code>. So, when <code>f₁</code> and <code>f₂</code> are extenionally
equal, we have the following chain of equalities:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-21' mode="ace/mode/lean" readonly="true">  f₁ = extfun_app ⟦f₁⟧ = extfun_app ⟦f₂⟧ = f₂
</juicy-ace-editor><div id='lean-full-code-21' style='display:none'>  f₁ = extfun_app ⟦f₁⟧ = extfun_app ⟦f₂⟧ = f₂
</div>
</div>
<p>
As a result, <code>f₁</code> is equal to <code>f₂</code>.
</p>
</div>
</div>

<div id="outline-container-org562dd61" class="outline-3">
<h3 id="Choice_Axioms"><a id="org562dd61"></a><span class="section-number-3"> 11.5</span> Choice</h3>
<div class="outline-text-3" id="text-Choice_Axioms">
<p>
To state the final axiom defined in the standard library, we need the
<code>nonempty</code> type, which is defined as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-22' mode="ace/mode/lean" readonly="true">class inductive nonempty (α : Sort u) : Prop
| intro : α → nonempty</juicy-ace-editor><div id='lean-full-code-22' style='display:none'>universe u
namespace hide

class inductive nonempty (α : Sort u) : Prop
| intro : α → nonempty

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-22').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Because <code>nonempty α</code> has type <code>Prop</code> and its constructor contains
data, it can only eliminate to <code>Prop</code>. In fact, <code>nonempty α</code> is
equivalent to <code>∃ x : α, true</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-23' mode="ace/mode/lean" readonly="true">example (α : Type u) : nonempty α ↔ ∃ x : α, true :=
iff.intro (λ ⟨a⟩, ⟨a, trivial⟩) (λ ⟨a, h⟩, ⟨a⟩)</juicy-ace-editor><div id='lean-full-code-23' style='display:none'>universe u

example (α : Type u) : nonempty α ↔ ∃ x : α, true :=
iff.intro (λ ⟨a⟩, ⟨a, trivial⟩) (λ ⟨a, h⟩, ⟨a⟩)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-23').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Our axiom of choice is now expressed simply as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-24' mode="ace/mode/lean" readonly="true">axiom choice {α : Sort u} : nonempty α → α</juicy-ace-editor><div id='lean-full-code-24' style='display:none'>namespace hide
universe u

axiom choice {α : Sort u} : nonempty α → α

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-24').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Given only the assertion <code>h</code> that <code>α</code> is nonempty, <code>choice h</code>
magically produces an element of <code>α</code>. Of course, this blocks any
meaningful computation: by the interpretation of <code>Prop</code>, <code>h</code> contains
no information at all as to how to find such an element. 
</p>

<p>
This is found in the <code>classical</code> namespace, so the full name of the
theorem is <code>classical.choice</code>. The choice principle is equivalent to
the principle of <i>indefinite description</i>, which can be expressed with
subtypes as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-25' mode="ace/mode/lean" readonly="true">noncomputable theorem indefinite_description {α : Sort u} (p : α → Prop) : 
  (∃ x, p x) → {x // p x} :=
λ h, choice (let ⟨x, px⟩ := h in ⟨⟨x, px⟩⟩)</juicy-ace-editor><div id='lean-full-code-25' style='display:none'>namespace hide
universe u

axiom choice {α : Sort u} : nonempty α → α
noncomputable theorem indefinite_description {α : Sort u} (p : α → Prop) : 
  (∃ x, p x) → {x // p x} :=
λ h, choice (let ⟨x, px⟩ := h in ⟨⟨x, px⟩⟩)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-25').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Because it depends on <code>choice</code>, Lean cannot generate bytecode for
<code>indefinite_description</code>, and so requires us to mark the definition as
<code>noncomputable</code>. Also in the <code>classical</code> namespace, the function <code>some</code> and the
property <code>some_spec</code> decompose the two parts of the output of
<code>indefinite_description</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-26' mode="ace/mode/lean" readonly="true">noncomputable def some {a : Sort u} {p : a → Prop} (h : ∃ x, p x) : a :=
subtype.elt_of (indefinite_description p h)

theorem some_spec {a : Sort u} {p : a → Prop} (h : ∃ x, p x) : p (some h) :=
subtype.has_property (indefinite_description p h)</juicy-ace-editor><div id='lean-full-code-26' style='display:none'>open classical
namespace hide
universe u

noncomputable def some {a : Sort u} {p : a → Prop} (h : ∃ x, p x) : a :=
subtype.elt_of (indefinite_description p h)

theorem some_spec {a : Sort u} {p : a → Prop} (h : ∃ x, p x) : p (some h) :=
subtype.has_property (indefinite_description p h)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-26').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The <code>choice</code> principle also erases the distinction between the
property of being <code>nonempty</code> and the more constructive property of
being <code>inhabited</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-27' mode="ace/mode/lean" readonly="true">noncomputable theorem inhabited_of_nonempty {α : Type u} : nonempty α → inhabited α :=
λ h, choice (let ⟨a⟩ := h in ⟨⟨a⟩⟩)</juicy-ace-editor><div id='lean-full-code-27' style='display:none'>universe u
open classical

noncomputable theorem inhabited_of_nonempty {α : Type u} : nonempty α → inhabited α :=
λ h, choice (let ⟨a⟩ := h in ⟨⟨a⟩⟩)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-27').text());">Try it yourself &raquo;</button></div>
</div>

<p>
In the next section, we will see that <code>propext</code>, <code>funext</code>, and
<code>choice</code>, taken together, imply the law of the excluded middle and the
decidability of all propositions. Using those, one can strengthen the
principle of indefinite description as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-28' mode="ace/mode/lean" readonly="true">check (@strong_indefinite_description :
        Π {α : Sort u} (p : α → Prop), nonempty α → {x // (∃ (y : α), p y) → p x})</juicy-ace-editor><div id='lean-full-code-28' style='display:none'>universe u
open classical

check (@strong_indefinite_description :
        Π {α : Sort u} (p : α → Prop), nonempty α → {x // (∃ (y : α), p y) → p x})
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-28').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Assuming the ambient type <code>α</code> is nonempty,
<code>strong_indefinite_description p</code> produces an element of <code>α</code>
satisfying <code>p</code> if there is one. The data component of this definition
is conventionally known as <i>Hilbert's epsilon function</i>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-29' mode="ace/mode/lean" readonly="true">check (@epsilon : Π {α : Sort u} [nonempty α], (α → Prop) → α)

check (@epsilon_spec : ∀ {a : Sort u} {p : a → Prop} (hex : ∃ (y : a), p y), 
         p (@epsilon _ (nonempty_of_exists hex) p))</juicy-ace-editor><div id='lean-full-code-29' style='display:none'>universe u
open classical

check (@epsilon : Π {α : Sort u} [nonempty α], (α → Prop) → α)

check (@epsilon_spec : ∀ {a : Sort u} {p : a → Prop} (hex : ∃ (y : a), p y), 
         p (@epsilon _ (nonempty_of_exists hex) p))
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-29').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-org8734547" class="outline-3">
<h3 id="org8734547"><span class="section-number-3"> 11.6</span> The Law of the Excluded Middle</h3>
<div class="outline-text-3" id="text-1-6">
<p>
The law of the excluded middle is the following
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-30' mode="ace/mode/lean" readonly="true">check (@em : ∀ (p : Prop), p ∨ ¬p)</juicy-ace-editor><div id='lean-full-code-30' style='display:none'>open classical
namespace hide
check (@em : ∀ (p : Prop), p ∨ ¬p)
end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-30').text());">Try it yourself &raquo;</button></div>
</div>
<p>
<a target='_blank' href="http://en.wikipedia.org/wiki/Diaconescu's_theorem">Diaconescu's theorem</a> states that the axiom of choice is sufficient to
derive the law of excluded middle. More precisely, it shows that the
law of the excluded middle follows from <code>classical.choice</code>, <code>propext</code>,
and <code>funext</code>. We sketch the proof that is found in the standard
library.
</p>

<p>
First, we import the necessary axioms, fix a parameter, <code>p</code>, and
define two predicates <code>U</code> and <code>V</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-31' mode="ace/mode/lean" readonly="true">open classical

section diaconescu
parameter  p : Prop

def U (x : Prop) : Prop := x = true ∨ p
def V (x : Prop) : Prop := x = false ∨ p

lemma exU : ∃ x, U x := ⟨true, or.inl rfl⟩
lemma exV : ∃ x, V x := ⟨false, or.inl rfl⟩

end diaconescu
</juicy-ace-editor><div id='lean-full-code-31' style='display:none'>open classical

section diaconescu
parameter  p : Prop

def U (x : Prop) : Prop := x = true ∨ p
def V (x : Prop) : Prop := x = false ∨ p

lemma exU : ∃ x, U x := ⟨true, or.inl rfl⟩
lemma exV : ∃ x, V x := ⟨false, or.inl rfl⟩

end diaconescu
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-31').text());">Try it yourself &raquo;</button></div>
</div>
<p>
If <code>p</code> is true, then every element of <code>Prop</code> is in both <code>U</code> and
<code>V</code>. If <code>p</code> is false, then <code>U</code> is the singleton <code>true</code>, and <code>V</code> is the
singleton <code>false</code>.
</p>

<p>
Next, we use <code>some</code> to choose an element from each of <code>U</code> and <code>V</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-32' mode="ace/mode/lean" readonly="true">noncomputable def u := some exU
noncomputable def v := some exV

lemma u_def : U u := some_spec exU
lemma v_def : V v := some_spec exV</juicy-ace-editor><div id='lean-full-code-32' style='display:none'>open classical

section diaconescu
parameter  p : Prop

def U (x : Prop) : Prop := x = true ∨ p
def V (x : Prop) : Prop := x = false ∨ p

lemma exU : ∃ x, U x := ⟨true, or.inl rfl⟩
lemma exV : ∃ x, V x := ⟨false, or.inl rfl⟩

noncomputable def u := some exU
noncomputable def v := some exV

lemma u_def : U u := some_spec exU
lemma v_def : V v := some_spec exV

end diaconescu
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-32').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Each of <code>U</code> and <code>V</code> is a disjunction, so <code>u_def</code> and <code>v_def</code> represent
four cases. In one of these cases, <code>u = true</code> and <code>v = false</code>, and in
all the other cases, <code>p</code> is true. Thus we have:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-33' mode="ace/mode/lean" readonly="true">lemma not_uv_or_p : u ≠ v ∨ p :=
or.elim u_def
  (assume hut : u = true,
    or.elim v_def
      (assume hvf : v = false,
        have hne : u ≠ v, from eq.symm hvf ▸ eq.symm hut ▸ true_ne_false,
        or.inl hne)
      (assume hp : p, or.inr hp))
  (assume hp : p, or.inr hp)</juicy-ace-editor><div id='lean-full-code-33' style='display:none'>open classical
section diaconescu
parameter  p : Prop

def U (x : Prop) : Prop := x = true ∨ p
def V (x : Prop) : Prop := x = false ∨ p

lemma exU : ∃ x, U x := ⟨true, or.inl rfl⟩
lemma exV : ∃ x, V x := ⟨false, or.inl rfl⟩

noncomputable def u := some exU
noncomputable def v := some exV

lemma u_def : U u := some_spec exU
lemma v_def : V v := some_spec exV

lemma not_uv_or_p : u ≠ v ∨ p :=
or.elim u_def
  (assume hut : u = true,
    or.elim v_def
      (assume hvf : v = false,
        have hne : u ≠ v, from eq.symm hvf ▸ eq.symm hut ▸ true_ne_false,
        or.inl hne)
      (assume hp : p, or.inr hp))
  (assume hp : p, or.inr hp)

end diaconescu
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-33').text());">Try it yourself &raquo;</button></div>
</div>
<p>
On the other hand, if <code>p</code> is true, then, by function extensionality
and propositional extensionality, <code>U</code> and <code>V</code> are equal. By the
definition of <code>u</code> and <code>v</code>, this implies that they are equal as well.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-34' mode="ace/mode/lean" readonly="true">lemma p_implies_uv : p → u = v :=
assume hp : p,
have hpred : U = V, from
  funext (take x : Prop,
    have hl : (x = true ∨ p) → (x = false ∨ p), from
      assume a, or.inr hp,
    have hr : (x = false ∨ p) → (x = true ∨ p), from
      assume a, or.inr hp,
    show (x = true ∨ p) = (x = false ∨ p), from
      propext (iff.intro hl hr)),
have h₀ : ∀ exU exV,
    @classical.some _ U exU = @classical.some _ V exV,
  from hpred ▸ λ exU exV, rfl,
show u = v, from h₀ _ _</juicy-ace-editor><div id='lean-full-code-34' style='display:none'>open classical
section diaconescu
parameter  p : Prop

def U (x : Prop) : Prop := x = true ∨ p
def V (x : Prop) : Prop := x = false ∨ p

lemma exU : ∃ x, U x := ⟨true, or.inl rfl⟩
lemma exV : ∃ x, V x := ⟨false, or.inl rfl⟩

noncomputable def u := some exU
noncomputable def v := some exV

lemma u_def : U u := some_spec exU
lemma v_def : V v := some_spec exV

lemma not_uv_or_p : ¬(u = v) ∨ p :=
or.elim u_def
  (assume hut : u = true,
    or.elim v_def
      (assume hvf : v = false,
        have hne : u ≠ v, from eq.symm hvf ▸ eq.symm hut ▸ true_ne_false,
        or.inl hne)
      (assume hp : p, or.inr hp))
  (assume hp : p, or.inr hp)

lemma p_implies_uv : p → u = v :=
assume hp : p,
have hpred : U = V, from
  funext (take x : Prop,
    have hl : (x = true ∨ p) → (x = false ∨ p), from
      assume a, or.inr hp,
    have hr : (x = false ∨ p) → (x = true ∨ p), from
      assume a, or.inr hp,
    show (x = true ∨ p) = (x = false ∨ p), from
      propext (iff.intro hl hr)),
have h₀ : ∀ exU exV,
    @classical.some _ U exU = @classical.some _ V exV,
  from hpred ▸ λ exU exV, rfl,
show u = v, from h₀ _ _
end diaconescu
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-34').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Putting these last two facts together yields the desired conclusion:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-35' mode="ace/mode/lean" readonly="true">theorem em : p ∨ ¬p :=
have h : ¬(u = v) → ¬p, from mt p_implies_uv,
  or.elim not_uv_or_p
    (assume hne : ¬(u = v), or.inr (h hne))
    (assume hp : p, or.inl hp)</juicy-ace-editor><div id='lean-full-code-35' style='display:none'>open classical
section diaconescu
parameter  p : Prop

def U (x : Prop) : Prop := x = true ∨ p
def V (x : Prop) : Prop := x = false ∨ p

lemma exU : ∃ x, U x := ⟨true, or.inl rfl⟩
lemma exV : ∃ x, V x := ⟨false, or.inl rfl⟩

noncomputable def u := some exU
noncomputable def v := some exV

lemma u_def : U u := some_spec exU
lemma v_def : V v := some_spec exV

lemma not_uv_or_p : ¬(u = v) ∨ p :=
or.elim u_def
  (assume hut : u = true,
    or.elim v_def
      (assume hvf : v = false,
        have hne : ¬(u = v), from eq.symm hvf ▸ eq.symm hut ▸ true_ne_false,
        or.inl hne)
      (assume hp : p, or.inr hp))
  (assume hp : p, or.inr hp)

lemma p_implies_uv : p → u = v :=
assume hp : p,
have hpred : U = V, from
  funext (take x : Prop,
    have hl : (x = true ∨ p) → (x = false ∨ p), from
      assume a, or.inr hp,
    have hr : (x = false ∨ p) → (x = true ∨ p), from
      assume a, or.inr hp,
    show (x = true ∨ p) = (x = false ∨ p), from
      propext (iff.intro hl hr)),
have h₀ : ∀ exU exV,
    @classical.some _ U exU = @classical.some _ V exV,
  from hpred ▸ λ exU exV, rfl,
show u = v, from h₀ _ _

theorem em : p ∨ ¬p :=
have h : ¬(u = v) → ¬p, from mt p_implies_uv,
  or.elim not_uv_or_p
    (assume hne : ¬(u = v), or.inr (h hne))
    (assume hp : p, or.inl hp)

end diaconescu
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-35').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Consequences of excluded middle include double-negation elimination,
proof by cases, and proof by contradiction, all of which are described
in <a href="#" onclick="myModule.loadTutorial('03_Propositions_and_Proofs.html', 'Classical_Logic')">Section 3.5</a>. The law of the excluded middle and propositional extensionality imply
propositional completeness:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-36' mode="ace/mode/lean" readonly="true">theorem prop_complete (a : Prop) : a = true ∨ a = false :=
or.elim (em a)
  (λ t, or.inl (propext (iff.intro (λ h, trivial) (λ h, t))))
  (λ f, or.inr (propext (iff.intro (λ h, absurd h f) (λ h, false.elim h))))</juicy-ace-editor><div id='lean-full-code-36' style='display:none'>open classical
namespace hide

theorem prop_complete (a : Prop) : a = true ∨ a = false :=
or.elim (em a)
  (λ t, or.inl (propext (iff.intro (λ h, trivial) (λ h, t))))
  (λ f, or.inr (propext (iff.intro (λ h, absurd h f) (λ h, false.elim h))))

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-36').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Together with choice, we also get the stronger principle that every
proposition is decidable. Recall that the class of <code>decidable</code>
propositions is defined as follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-37' mode="ace/mode/lean" readonly="true">class inductive decidable (p : Prop)
| is_false : ¬ p → decidable
| is_true :  p → decidable</juicy-ace-editor><div id='lean-full-code-37' style='display:none'>namespace hide

class inductive decidable (p : Prop)
| is_false : ¬ p → decidable
| is_true :  p → decidable

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-37').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In contrast to <code>p ∨ ¬ p</code>, which can only eliminate to <code>Prop</code>, the type
<code>decidable p</code> is equivalent to the sum type <code>p ⊕ ¬ p</code>, which can
elminate to any type. It is this data that is needed to write an
if-then-else expression.
</p>

<p>
As an example of classical reasoning, we use <code>some</code> to show that if
<code>f : α → β</code> is injective and <code>α</code> is inhabited, then <code>f</code> has a left
inverse. To define the left inverse <code>linv</code>, we use a dependent
if-then-else expression.  Recall that <code>if h : c then t else e</code> is
notation for <code>dite c (λ h : c, t) (λ h : ¬ c, e)</code>.  In the definition
of <code>linv</code>, choice is used twice: first, to show that <code>(∃ a : A, f a =
b)</code> is "decidable," and then to choose an <code>a</code> such that <code>f a =
b</code>. Notice that we make <code>prop_decidable</code> a local instance to justify the
if-then-else expression.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-38' mode="ace/mode/lean" readonly="true">open classical function
local attribute [instance] prop_decidable

noncomputable definition linv {α β : Type} [h : inhabited α] (f : α → β) : β → α :=
λ b : β, if ex : (∃ a : α, f a = b) then some ex else arbitrary α

theorem linv_comp_self {α β : Type} {f : α → β}
    [inhabited α] (inj : injective f) :
  linv f ∘ f = id :=
funext (take a,
  have ex  : ∃ a₁ : α, f a₁ = f a, from exists.intro a rfl,
  have   feq : f (some ex) = f a, from some_spec ex,
  calc linv f (f a) = some ex :  dif_pos ex
             ...    = a       :  inj feq)
</juicy-ace-editor><div id='lean-full-code-38' style='display:none'>open classical function
local attribute [instance] prop_decidable

noncomputable definition linv {α β : Type} [h : inhabited α] (f : α → β) : β → α :=
λ b : β, if ex : (∃ a : α, f a = b) then some ex else arbitrary α

theorem linv_comp_self {α β : Type} {f : α → β}
    [inhabited α] (inj : injective f) :
  linv f ∘ f = id :=
funext (take a,
  have ex  : ∃ a₁ : α, f a₁ = f a, from exists.intro a rfl,
  have   feq : f (some ex) = f a, from some_spec ex,
  calc linv f (f a) = some ex :  dif_pos ex
             ...    = a       :  inj feq)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-38').text());">Try it yourself &raquo;</button></div>
</div>
<p>
From a classical point of view, <code>linv</code> is a function. From a
constructive point of view, it is unacceptable; because there is no way
to implement such a function in general, the construction is not
informative.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
